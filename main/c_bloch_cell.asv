classdef c_bloch_cell
% Class for simulating a bloch cell, using FDFD complex-k solver
%
% Authors: bohan zhang
%
% Description:
%
% Notes:
%   - propagation direction coordinate is 'x'. 
%   - transverse (in plane) direction coordinate is 'y'.
%   - transverse (out of plane) direction is 'z'.
%
% Inputs to constructor:
%   Inputs are name-value pairs:
%   'discretization'
%       type: double, scalar or 1x2 vector
%       desc: discretization along x and y, in units of 'units'
%             if scalar, then dx = dy = discretization
%             if vector, then discretization = [ dy dx ]
%
%   'units'
%       type: string
%       desc: name and scaling of spatial units, supports 'm'
%             (meters), 'mm' (millimeters), 'um' (microns), 'nm'
%             (nanometers)
%
%   'lambda'
%       type: double, scalar
%       desc: wavelength to solve at, in units 'units'
%
%   'background_index'
%       type: double, scalar
%       desc: value of background index
%
%   'domain_size'
%       type: 1x2 array, double
%       desc: domain size, [ y height, x length ]
%
%   'num_cells'
%       type: integer, scalar
%       desc: OPTIONAL: pick the number of grating cells to repeat when
%             drawing/calculating Ez
%
% Example usage:
    
    properties
        
        N;                  % index profile
        dx;                 % discretization in x (dir of propagation)
        dy;                 % discretization in y (transverse direction)
        units;              % name and scaling of spatial units, supports 'm', 'mm', 'um', 'nm'
        lambda;             % free space wavelength, units 'units'
        domain_size;        % [ max_y, max_x ], where y = transverse and x = direction of propagation
        x_coords;           % vector of x coordinates (dir of prop)
        y_coords;           % vector of y coords (transverse dir)
        
        % struct that holds simulation options
        % current options are:
        %   'num_modes'     - number of modes
        %   'BC'            - boundary conditions, 0 for pec 1 for pmc i think
        %   'pml_options'   - pml options, see complexk solver for details
        %                     PML_options(1): PML in y direction (yes=1 or no=0)
        %                     PML_options(2): length of PML layer in nm
        %                     PML_options(3): strength of PML in the complex plane
        %                     PML_options(4): PML polynomial order (1, 2, 3...)
        sim_opts;
        
        % mode characteristics
        k;                  % complex k, units rad/'units'
        Phi;                % field envelope
        numcells;           % number of cells repeated in E_z
        E_z                 % saves n_periods of the field, Phi(x,y)*exp(jkx) (z stands for z polarization)
        k_vs_mode;          % k vs mode #
        Phi_vs_mode;        % Phi vs mode #, dimensions y vs. x vs mode #
        chosen_mode_num;    % which mode was chosen
        E_z_for_overlap;    % Field for mode overlapping. One unit cell with only real(k) in the phase
        
        % DEBUG struct for holding temporary values that are useful during
        % debugging
        %   Current fields: k_all, phi_all, unguided_power, guided_power,
        %                   p_rad_up, Sx_up, Sx_down, Sy_up, Sy_down, Sx_in
        %                   P_rad_up_onecell, P_rad_down_onecell,
        %                   Sx, Sy, P_per_y_slice, P_per_x_slice
        %   Some of the above fields may have been removed.
        debug;
        
    end     % end properties
    
    
    methods
        
        % -----------------------------------------------------------------
        % Constructor
        
        function obj = c_bloch_cell( varargin )
            
            % parse inputs
            inputs = {  'discretization',   'none', ...
                        'units',            'um',   ...
                        'lambda',           'none', ...
                        'background_index', 1.0,    ...
                        'domain_size',      'none', ...
                        'numcells',         10 ...
                     }; 
                 
            p = f_parse_varargin( inputs, varargin{:} );
        
            % sort the inputs
            if length(p.discretization) == 1
                obj.dx          = p.discretization;
                obj.dy          = p.discretization;
            elseif length(p.discretization) == 2
                obj.dx          = p.discretization(2);
                obj.dy          = p.discretization(1);
                if abs(obj.dx - obj.dy) >= 1e-5
                    warning('dx and dy are different. Bloch solver does not currently support different discretizations for different axes');
                end
            else
                error('Input ''discretization'' must either be a scaler or a 1x2 vector');
            end

            obj.units.name  = p.units;
            switch( obj.units.name )
                case 'm'
                    obj.units.scale = 1;
                case 'mm'
                    obj.units.scale = 1e-3;
                case 'um'
                    obj.units.scale = 1e-6;
                case 'nm'
                    obj.units.scale = 1e-9;
            end

            obj.lambda = p.lambda;
            
            % new version of creating background dielectric that rounds
            % the dimensions
            obj.domain_size = p.domain_size;
            nx              = round( obj.domain_size(2)/obj.dx );                                           % number of x samples
            obj.x_coords    = 0 : obj.dx : ( (nx-1) * obj.dx );
            ny              = round( obj.domain_size(1)/obj.dy );                                           % number of y samples
            obj.y_coords    = 0 : obj.dy : ( (ny-1) * obj.dy );
            obj.N           = p.background_index * ones( length( obj.y_coords ), length( obj.x_coords ) );  % dimensions of y vs. x
            
            % check discretization fits in integer amt
            if abs(obj.x_coords(end) - (obj.domain_size(2) - obj.dx)) >= 1e-10
                % the discretization doesn't fit into x
                fprintf('Warning: dx doesn''t fit integer times into the x domain size.\n');
                
                % override the domain size
                fprintf('Overriding domain. Old domain x size was: %f. New domain x size is: %f\n\n',  obj.domain_size(2), obj.x_coords(end) + obj.dx);
                obj.domain_size(2) = obj.x_coords(end) + obj.dx;
                obj.domain_size(2) = obj.dx * round( obj.domain_size(2)/obj.dx );   % round
            end
            if abs(obj.y_coords(end) - (obj.domain_size(1) - obj.dy)) >= 1e-10
                % the discretization doesn't fit into x
                fprintf('Warning: dy doesn''t fit integer times into the y domain size.\n');
                
                % override the domain size
                fprintf('Overriding domain. Old domain y size was: %f. New domain y size is: %f\n\n', obj.domain_size(1), obj.y_coords(end) + obj.dy);
                obj.domain_size(1) = obj.y_coords(end) + obj.dy;
                obj.domain_size(1) = obj.dy * round( obj.domain_size(1)/obj.dy );   % round
            end
            
            % set number of cells, not sure if used anymore
            obj.numcells = p.numcells;
            
        end     % end constructor
        
        % -----------------------------------------------------------------
        % Drawing functions
        
        function obj = addLayer( obj, min_y, height_y, index )
            % Draws a horizontal layer of dielectric
            %
            % Inputs:
            %   min_y
            %       Desc: scalar double, minimum y
            %   height_y
            %       Desc: scalar double, height/thickness of layer
            %   index
            %       Desc: scalar double, index of refraction of layer
            
            y = obj.y_coords;
            
            % fill in the layer
            obj.N( y > (min_y - obj.dy/2) & y <= (min_y + height_y - obj.dy/2), : ) = index; 
            
        end     % end function addLayer()
        
        function obj = addRect( obj, min_x, min_y, width_x, height_y, index )
            % Draws a rectangle
            %
            % Inputs:
            %   min_x
            %       Desc: scalar double, left edge of rectangle
            %   min_y
            %       Desc: scalar double, bottom edge of rectangle
            %   width_x
            %       Desc: scalar double, width of rectangle
            %   height_y
            %       Desc: scalar double, height of rectangle
            %   index
            %       Desc: index of refraction
            
            x = obj.x_coords;
            y = obj.y_coords;
            
            % fill in the rect
            obj.N( y > (min_y - obj.dy/2) & y <= (min_y + height_y - obj.dy/2), ...
                    x > (min_x - obj.dx/2) & x <= (min_x + width_x - obj.dx/2) ) = index; 
            
        end     % end function addRect()
        
        % -----------------------------------------------------------------
        % Running simulations
        
        function obj = runSimulation( obj, num_modes, BC, pml_options, guessk, OPTS )
            % Runs new mode solver
            %
            % Description:
            %   Runs complex-k mode solver. Stores the mode with the most
            %   guided power. Calculates up/down power, directivity,
            %   angle of maximum radiation, and scattering strength.
            %
            % Inputs:
            %   num_modes
            %       type: integer
            %       desc: # of modes (max) to simulate
            %   BC
            %       type: integer
            %       desc: 0 for PEC, 1 for PMC
            %   pml_options
            %       type: array, double
            %       desc: 1x4 Array with the following elements:
            %               PML_options(1): PML in y direction (yes=1 or no=0)
            %               PML_options(2): length of PML layer in nm
            %               PML_options(3): strength of PML in the complex plane
            %               PML_options(4): PML polynomial order (1, 2, 3...)
            %   guessk
            %       type: scalar, double (can be complex)
            %       desc: guess k value. Works best when closest to desired
            %             mode. In units rad/'units'
            %   OPTS
            %       type: struct
            %       desc: optional options with the following fields
            %           'mode_to_overlap'
            %               type: matrix, double
            %               desc: mode to overlap
            %
            % Sets these properties:
            %   obj.k
            %       units rad/'units'
            %   obj.Phi
            %       dimensions y vs. x (x is dir. of propagation)
            %   obj.E_z
            %       field repeated, i can't remember why or if i use this
            %   obj.directivity
            %       up/down power ratio
            

            % default OPTS
            if nargin < 6
                OPTS = struct();
            end
            
            % spatial variables, in units nm
            nm          = 1e9;
            a           = obj.domain_size(2) * obj.units.scale * nm;
            lambda_nm   = obj.lambda * obj.units.scale * nm;
            dx_nm       = obj.dx * obj.units.scale * nm;
            guessk_nm   = guessk / ( obj.units.scale * nm );                % units rad/nm

            % store options
            obj.sim_opts = struct( 'num_modes', num_modes, 'BC', BC, 'pml_options', pml_options, 'OPTS', OPTS );

            % set guessk if not entered
            if nargin < 5
                guessk = pi/(2*a);
            end
            
            % run solver
            k0_nm           = 2*pi/lambda_nm;
            [Phi_all, k_nm] = complexk_mode_solver_2D_PML( obj.N, ...
                                                       dx_nm, ...
                                                       k0_nm, ...
                                                       num_modes, ...
                                                       guessk_nm, ...
                                                       BC, ...
                                                       pml_options );
                                                   
            % re-scale k to units 'units'
            k_vs_mode = k_nm * nm * obj.units.scale;
            
            % save k and phi vs mode #
            obj.k_vs_mode   = k_vs_mode;
            obj.Phi_vs_mode = Phi_all;
            
            % pick which mode to keep
            if isfield( OPTS, 'mode_to_overlap' )
                % pick mode with best overlap
                obj = obj.choose_mode( OPTS.mode_to_overlap );
            else
                % pick mode guided mode
                obj = obj.choose_mode(); 
            end
            
            % stitch together full e field, with the request number of
            % periods
            [obj, E_z]  = obj.stitch_E_field( obj.Phi, obj.k, obj.numcells );
            obj.E_z     = E_z;
            
            % for mode overlapping, stitch together single unit cell of E
            % field, using only real(k)
            [obj, E_z_for_overlap]  = obj.stitch_E_field( obj.Phi, real(obj.k), 1 );
            obj.E_z_for_overlap     = E_z_for_overlap;
            
            % pick slices of field to compute directivity, angle, etc.
            h_pml_d = round( pml_options(2)/obj.dy );                       % size of pml in discretizations
            y_up    = size( obj.E_z, 1 ) - h_pml_d - 1;
            y_down  = h_pml_d+2;
            
            % calculate output angle
            obj = obj.calc_output_angle( y_up, y_down );
            
            % calculate up/down directivity
            obj             = obj.calc_radiated_power();
            obj.directivity = obj.P_rad_up/obj.P_rad_down;
                    
            % calculate power scattering strength
            obj = obj.calc_scattering_strength();
            
            
        end     % end function runSimulation()
        
        function obj = choose_mode( obj, mode_to_overlap )
            % Function that chooses which mode becomes the accepted mode
            %
            % Inputs:
            %   mode_to_overlap
            %       type: matrix, double
            %       desc: this function
            %             will choose the mode with the closest overlap.
            %             Otherwise, the function will choose the mode with
            %             the mode guided power
            %
            % Sets these properties:
            %   obj.k
            %       prop. k of chosen mode
            %   obj.Phi
            %       field envelope of chosen mode
            %   obj.chosen_mode_num
            %       index of chosen mode (chosen mode k = obj.k_vs_mode(
            %       obj.chosen_mode_num))

            % run overlaps
            [obj, max_overlaps] = obj.calc_mode_overlaps( mode_to_overlap );

            % keep mode with highest overlap
            [~, indx_k]         = max( max_overlaps );        
            obj.k               = obj.k_vs_mode(indx_k);
            obj.Phi             = obj.Phi_vs_mode(:,:,indx_k);
            obj.chosen_mode_num = indx_k;
            
        end     % end function choose_mode()
        
        
    end     % end methods
    
    
end     % end classdef

